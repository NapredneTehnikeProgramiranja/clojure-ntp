(ns clojure-ntp.spec
  (:require [clojure.spec.alpha :as s]
            [clojure.repl :refer [doc]]))

:keyword
;; => :keyword

::qualified-keyword
;; => :clojure-ntp.spec/qualified-keyword

(s/def ::big-even (s/and int? even? #(> % 1000)))

(s/valid? ::big-even 200)
;; => false
(s/valid? ::big-even 1100)
;; => true

;; -----------------------------------------------------------------------------
;; clojure.spec examples

(s/def ::name-or-id (s/or :name string?
                          :id   int?))

(s/valid? ::name-or-id "abc")
;; => true
(s/valid? ::name-or-id 100)
;; => true
(s/valid? ::name-or-id :foo)
;; => false

(s/conform ::name-or-id "abc")
;; => [:name "abc"]
(s/conform ::name-or-id 100)
;; => [:id 100]

(s/valid? (s/nilable ::name-or-id) nil)
;; => true
(s/valid? (s/nilable ::name-or-id) "abc")
;; => true
(s/valid? (s/nilable ::name-or-id) 0.1)
;; => false

(s/explain ::name-or-id {:a 1})
;; =>
;; val: {:a 1} fails spec: :clojure-ntp.spec/name-or-id at: [:name] predicate: string?
;; val: {:a 1} fails spec: :clojure-ntp.spec/name-or-id at: [:id] predicate: int?

(s/explain ::name-or-id 1)
;; => Success!

(doc s/keys)
;; =>
;; -------------------------
;; clojure.spec.alpha/keys
;; ([& {:keys [req req-un opt opt-un gen]}])
;; Macro
;;   Creates and returns a map validating spec. :req and :opt are both
;;   vectors of namespaced-qualified keywords. The validator will ensure
;;   the :req keys are present. The :opt keys serve as documentation and
;;   may be used by the generator.

;;   The :req key vector supports 'and' and 'or' for key groups:

;;   (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])

;;   There are also -un versions of :req and :opt. These allow
;;   you to connect unqualified keys to specs.  In each case, fully
;;   qualfied keywords are passed, which name the specs, but unqualified
;;   keys (with the same name component) are expected and checked at
;;   conform-time, and generated during gen:

;;   (s/keys :req-un [:my.ns/x :my.ns/y])

;;   The above says keys :x and :y are required, and will be validated
;;   and generated by specs (if they exist) named :my.ns/x :my.ns/y
;;   respectively.

;;   In addition, the values of *all* namespace-qualified keys will be validated
;;   (and possibly destructured) by any registered specs. Note: there is
;;   no support for inline value specification, by design.

;;   Optionally takes :gen generator-fn, which must be a fn of no args that
;;   returns a test.check generator.
